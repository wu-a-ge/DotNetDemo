//Copyright (C) Microsoft Corporation.  All rights reserved.

using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using Microsoft.VisualStudio.DebuggerVisualizers;
using System.Linq.Expressions;
using ExpressionVisualizer;

namespace LINQConsoleApplication1 {
    class Program {

        //The Expression Tree Visualizer can be used in a debug environment to visualize expressions.  To use 
        //the visualizer the dll generated by the ExpressionTreeVisualizer project must be copied to 
        // \My Documents\Visual Studio 2008\Visualizers.  This console program provides the ability to
        //host the visualizer outside of Visual Studio without copying the DLL.
        static void Main() 
        {

            var express = CallExpression();
            VisualizerDevelopmentHost host = new VisualizerDevelopmentHost(express,
                                                 typeof(ExpressionTreeVisualizer),
                                                 typeof(ExpressionTreeVisualizerObjectSource));
            host.ShowVisualizer();   
            

        }
        private static Expression LinqQueryExpress()
        {
            var languages = new[] { "C#", "J#", "VB", "Delphi", "F#", "COBOL", "Python" };
            var queryable = languages.AsQueryable().Where(l => l.EndsWith("#") && l != "j#");
            return queryable.Expression;
        }

        private static Expression CallExpression()
        {    
            //var property = typeof(IFoo).GetProperty("Bar");
            //var target = Expression.Parameter(typeof(object));
            //var propertyValue = Expression.Parameter(typeof(object));
            //var castTarget = Expression.Convert(target, typeof(IFoo));
            //var castPropertyValue = Expression.Convert(propertyValue, property.PropertyType);
            //var setPropertyValue = Expression.Call(castTarget, property.GetSetMethod(), castPropertyValue);
            //return Expression.Lambda<Action<object, object>>(setPropertyValue, target, propertyValue);

            var property = typeof(IFoo).GetProperty("Bar");
            var target = Expression.Parameter(typeof(IFoo), "a");
            var propertyValue = Expression.Parameter(typeof(Bar), "b");
            var setPropertyValue = Expression.Call(target, property.GetSetMethod(), propertyValue);
            return Expression.Lambda<Action<IFoo, Bar>>(setPropertyValue, target, propertyValue);

        }
        private static Expression ConvertExpressionAndMemberExpress()
        {
            var property = typeof(IFoo).GetProperty("Bar");
            var target = Expression.Parameter(typeof(object),"a");
            var castTarget = Expression.Convert(target, typeof(IFoo));
            var getPropertyValue = Expression.Property(castTarget, property);
            var castPropertyvalue = Expression.Convert(getPropertyValue, typeof(object));
            return Expression.Lambda<Func<object, object>>(castPropertyvalue, target);

            //var property = typeof(IFoo).GetProperty("Bar");
            //var target = Expression.Parameter(typeof(IFoo),"a");
            //var getPropertyValue = Expression.Property(target, property);
            //return Expression.Lambda<Func<IFoo, Bar>>(getPropertyValue, target);

        }
        public class Bar { }
        public interface IFoo
        {
            Bar Bar { get; set; }
        }
        public class Foo1 : IFoo
        {
            public Bar Bar { get; set; }
        }
        public class Foo2 : IFoo
        {
            public Bar Bar { get; set; }
        }
        public class Foo3 : IFoo
        {
            public Bar Bar { get; set; }
        }
        
    }
}
